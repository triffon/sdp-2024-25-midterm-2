/***********************************************************************
 * Моля, преименувате файла, като:
 *   - замените G с групата, с която ходите на упражнения
 *   - замените F с вашия факултетен номер
 **********************************************************************/

/***********************************************************************
Задача 3. Асистентът ви по СДП отива да декларира в НАП доходите си от 
ФМИ, но това се оказва тежка задача! Ако асистентът попадне на грешното 
гише, го препращат на друго. Гишетата са представени като двусвързан 
списък от тройни кутии от вида:
struct node { int code; node *prev, *next; }; в който се съдържа точно 
един елемент със стойност 0, който означава търсеното гише. Асистентът 
започва от някое гише и поглежда неговия код code. Ако той е отрицателно 
число, трябва да се придвижи към началото на списъка с -code стъпки, а 
ако попадне на положително число – с code стъпки към края на списъка. В 
допълнение, на всяко n-то посетено поред гише пише "Тук не е 
информация!1!11!". Асистентът не е конфликтна личност и затова при 
попадане на такова гише с ненулев код code моментално го изтрива от 
списъка и преминава към гишето непосредствено отляво, ако code < 0 или 
непосредствено отдясно, ако code > 0.
Да се реализира функция int steps(node* start, int n), която връща броя 
стъпки, след които асистентът стига до търсеното гише с код 0.
Пример: steps((-1 ⇔ 2 ⇔ 1 ⇔ 3 ⇔ -2 ⇔ 0 ⇔ 4), 2) = 8: 1,[3],-2,[2],1,[-2],1,0
************************************************************************/

struct node {
  int code;
  node *prev, *next;
};

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/
int steps(node* start, int n) {
    int stepCount = 0;
    node* current = start;

    while (current->code != 0) {
        stepCount++;

        // Проверка дали това е n-тото гише
        if (stepCount % n == 0) {
            // Понеже code != 0 (щом не сме приключили), изтриваме гишето
            node* toDelete = current;
            if (toDelete->prev != nullptr)
                toDelete->prev->next = toDelete->next;
            if (toDelete->next != nullptr)
                toDelete->next->prev = toDelete->prev;

            // Преминаваме към гишето вляво, ако code < 0, или вдясно, ако code > 0
            if (current->code < 0)
                current = toDelete->prev;
            else
                current = toDelete->next;

            // Изтриваме текущото гише (динамична памет)
            delete toDelete;

            // На n-тата стъпка не правим придвижване по code, защото гишето е премахнато
        } else {
            // Не е n-та стъпка, придвижваме се според code
            int code = current->code;
            if (code < 0)
                for (int i = 0; i < -code; i++)
                    current = current->prev;
            else
                for (int i = 0; i < code; i++)
                    current = current->next;
        }
    }
    return stepCount + 1;
}
/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "3_tests.hpp"

int main () {
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
