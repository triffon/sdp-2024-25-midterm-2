/***********************************************************************
 * Моля, преименувате файла, като:
 *   - замените G с групата, с която ходите на упражнения
 *   - замените F с вашия факултетен номер
 **********************************************************************/

/***********************************************************************
 Задача 6. Асистентът ви по СДП проверява контролна работа, но това се
 оказва тежка задача, тъй като е писано на хартия и листовете са
 разбъркани! Листовете са представени като двусвързан списък от тройни 
 кутии от вида: struct node { int dir, page; node *prev, *next; }; където 
 page указва номера на листа, а dir указва посоката, в която трябва да се
 търси следващия по номер лист. Ако dir е отрицателно число, листът трябва
 да се търси назад в списъка, ако е положително число – напред в списъка,
 а ако е 0 – това е последната страница. Листовете с отрицателен номер са
 чернова и трябва да се изтрият от списъка, тъй като не се четат. Да се 
 реализира функция int pages(node* start), която връща броя листове, които
 асистентът трябва да отгърне, започвайки от листа с номер 1, указан от
 start, за да прочете всички листи подред докато стигне до последната 
 страница. Асистентът не подрежда и не чете листовете, които прелиства,
 докато търси следващия номер, и изхвърля черновите при първо преминаване
 през тях. При грешка функцията да връща -1.
 Пример: pages(5↓ ⇔ 3→ ⇔ -2→ ⇔ 1→ ⇔ -1← ⇔ 2← ⇔ -3→ ⇔ 4←) → 13
************************************************************************/

struct node {
    int dir, page;
    node *prev, *next;
};

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/

// Функция за търсене на следващата страница
// dir > 0: търсене напред, dir < 0: търсене назад
// Връща указател към намерената страница или nullptr при грешка
node* find_next_page(node* start, int next_page, int direction, int &count) {
    node* curr = start;
    while (curr && curr->page != next_page) {
        // Придвижваме се в зададената посока
        curr = (direction > 0) ? curr->next : curr->prev;
        count++; // всяко придвижване броим като обръщане на лист

        if (curr && curr->page < 0) {
            // Чернова - премахваме
            node* toDelete = curr;
            if (toDelete->prev != nullptr)
                toDelete->prev->next = toDelete->next;
            if (toDelete->next != nullptr)
                toDelete->next->prev = toDelete->prev;
            // Позиционираме се пак така, че да продължим търсенето от предишната позиция
            curr = (direction > 0) ? curr->prev : curr->next;
            delete toDelete;
            // Продължаваме търсенето отново в същата посока
        }
    }
    return curr;
}

int pages(node* start) {
    int count = 0;
    node* curr = start;

    // ако curr не сочи към страницата с номер 1 - грешка
    if (curr == nullptr || curr -> page != 1)
        return -1;

    while (curr && curr->dir != 0)
        curr = find_next_page(curr, curr->page + 1, curr->dir, count);

    if (curr == nullptr)
        return -1;
    return count;
}
/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "6_tests.hpp"

int main () {
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
